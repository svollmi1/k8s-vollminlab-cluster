name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'clusters/**'
      - '.github/workflows/**'
      - 'terraform/**'
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened, ready_for_review]
    paths:
      - 'clusters/**'
      - '.github/workflows/**'
      - 'terraform/**'
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: write

defaults:
  run:
    shell: bash

env:
  KUBERNETES_VERSION: "1.30.2"
  RUN_SUFFIX: ${{ github.run_id }}-${{ github.run_number }}
  TRIVY_CACHE_DIR: /tmp/trivy-cache

jobs:
  validate-changes:
    name: Validate Kubernetes Manifests
    runs-on: vollminlab-1
    timeout-minutes: 10
    outputs:
      changed: ${{ steps.get-changed-files.outputs.changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install kubectl
        run: |
          set -euo pipefail
          echo "üì¶ Installing kubectl..."
          KUBECTL_VERSION="v${{ env.KUBERNETES_VERSION }}"
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Install yq
        run: |
          set -euo pipefail
          echo "üì¶ Installing yq..."
          sudo curl -L -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Get changed files
        id: get-changed-files
        run: |
          set -euo pipefail
          echo "üîç Finding changed files..."
          
          # Simple approach: only check if any cluster files exist in the latest commit
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, check if any cluster files were changed in the latest commit
            LATEST_COMMIT_FILES=$(git show --name-only --pretty=format: HEAD | grep -E '\.(yaml|yml)$' | grep '^clusters/' || echo "")
            CHANGED_FILES="$LATEST_COMMIT_FILES"
          else
            # For pushes, use the standard diff approach
            BASE_SHA="${{ github.event.before }}"
            if [[ -z "$BASE_SHA" ]]; then
              BASE_SHA="$(git rev-list --max-parents=0 HEAD | tail -1)"
            fi
            RANGE="$BASE_SHA..HEAD"
            CHANGED_FILES=$(git diff --name-only "$RANGE" | grep -E '\.(yaml|yml)$' | grep '^clusters/' || echo "")
          fi
          
          echo "Files changed in latest commit:"
          git show --name-only --pretty=format: HEAD
          
          echo "üîç DEBUG: CHANGED_FILES variable: '$CHANGED_FILES'"
          echo "üîç DEBUG: CHANGED_FILES length: ${#CHANGED_FILES}"
          echo "üîç DEBUG: Will set changed=false because no cluster files found"
          echo "Changed YAML files in clusters/: $CHANGED_FILES"
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "‚úÖ No YAML files changed in clusters directory"
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "CHANGED_FILES=" >> $GITHUB_ENV
          else
            echo "üìã Found changed cluster files - will run deployment validation"
            echo "changed=true" >> $GITHUB_OUTPUT
            {
              echo "CHANGED_FILES<<EOF"
              printf '%s\n' "$CHANGED_FILES"
              echo "EOF"
            } >> $GITHUB_ENV
          fi

      - name: Validate YAML syntax
        if: env.CHANGED_FILES != ''
        run: |
          set -euo pipefail
          echo "üîç Validating YAML syntax with yamllint..."
          
          # Install yamllint
          sudo apt-get update
          sudo apt-get install -y python3-pip
          sudo pip3 install yamllint
          
          # Create yamllint config for Kubernetes files
          cat > .yamllint << 'EOF'
          extends: default
          
          rules:
            document-start:
              present: false
            new-line-at-end-of-file:
              level: warning
            line-length:
              max: 200
            truthy:
              allowed-values: ['true', 'false', 'on', 'off']
          EOF
          
          # Get range for diff
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            RANGE="$BASE_SHA..HEAD"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ -z "$BASE_SHA" ]]; then
              BASE_SHA="$(git rev-list --max-parents=0 HEAD | tail -1)"
            fi
            RANGE="$BASE_SHA..HEAD"
          fi
          
          # Validate each changed YAML file
          printf '%s\n' "$CHANGED_FILES" | while IFS= read -r file; do
            if [[ -f "$file" ]]; then
              echo "Validating: $file"
              yamllint "$file" || {
                echo "‚ùå YAML lint error in $file"
              exit 1
            }
            fi
          done
          
          echo "‚úÖ All YAML files have valid syntax"

      - name: Validate Kubernetes schemas
        if: env.CHANGED_FILES != ''
        run: |
          set -euo pipefail
          echo "üîç Validating Kubernetes schemas with kubeconform..."
          
          # Install kubeconform
          curl -L https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64.tar.gz | tar xvzf -
          sudo mv kubeconform /usr/local/bin/
          kubeconform -version || kubeconform -v
          
          # Get range for diff
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            RANGE="$BASE_SHA..HEAD"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ -z "$BASE_SHA" ]]; then
              BASE_SHA="$(git rev-list --max-parents=0 HEAD | tail -1)"
            fi
            RANGE="$BASE_SHA..HEAD"
          fi
          
          # Validate each changed Kubernetes file
          printf '%s\n' "$CHANGED_FILES" | while IFS= read -r file; do
            if [[ -f "$file" ]] && grep -q "kind:" "$file" && grep -q "apiVersion:" "$file"; then
              KIND=$(yq eval '.kind' "$file")
              
              # Skip Flux CD resources that don't have schemas
              case "$KIND" in
                HelmRelease|OCIRepository|HelmRepository|Kustomization|Policy|ClusterPolicy)
                  echo "Skipping Flux/Kyverno resource (no schema): $KIND in $file"
                  continue
                  ;;
              esac
              
              echo "Validating schema for CHANGED file: $file"
              kubeconform -strict -ignore-missing-schemas -summary "$file" || {
                echo "‚ùå Kubernetes schema validation failed for CHANGED file: $file"
                exit 1
              }
            fi
          done
          
          echo "‚úÖ All Kubernetes resources have valid schemas"

      - name: Scan for secrets
        if: env.CHANGED_FILES != ''
        run: |
          set -euo pipefail
          echo "üîç Scanning changed files for secrets..."
          
          # Install gitleaks
          curl -L -o gitleaks.tar.gz "https://github.com/gitleaks/gitleaks/releases/download/v8.18.0/gitleaks_8.18.0_linux_x64.tar.gz"
          tar -xzf gitleaks.tar.gz
          sudo mv gitleaks /usr/local/bin/
          
          # Get range for diff
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            RANGE="$BASE_SHA..HEAD"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ -z "$BASE_SHA" ]]; then
              BASE_SHA="$(git rev-list --max-parents=0 HEAD | tail -1)"
            fi
            RANGE="$BASE_SHA..HEAD"
          fi
          
          # Create temporary directory and copy changed files
          TEMP_DIR=$(mktemp -d)
          printf '%s\n' "$CHANGED_FILES" | while IFS= read -r file; do
            if [[ -f "$file" ]]; then
              cp "$file" "$TEMP_DIR/"
            fi
          done
          
          cd "$TEMP_DIR"
          
          # Create gitleaks config in temp directory
          cat > gitleaks.toml << 'EOF'
          [extend]
          useDefault = true
          
          [allowlist]
          description = "Ignore SealedSecrets keys"
          regexes = [
            "-----BEGIN CERTIFICATE-----",
            "-----BEGIN PUBLIC KEY-----"
          ]
          EOF
          
          git init
          git config user.email "ci@example.com"
          git config user.name "CI"
          git add .
          git commit -m "CI scan" || true
          
          # Run gitleaks with custom config
          set +e
          gitleaks detect --source . --config gitleaks.toml --no-banner --exit-code 1
          rc=$?
          set -e
          if [ $rc -ne 0 ]; then
            echo "‚ùå Secrets detected in changed files"
            echo "Please remove any hardcoded secrets and use SealedSecrets instead"
              exit 1
            fi
          
          echo "‚úÖ No secrets detected in changed files"

  test-deployment:
    name: Flux Configuration Validation
    runs-on: vollminlab-2
    needs: validate-changes
    if: needs.validate-changes.result == 'success' && needs.validate-changes.outputs.changed == 'true'
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup kubectl
        run: |
          set -euo pipefail
          KUBECTL_VERSION="v${{ env.KUBERNETES_VERSION }}"
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

  server-side-validation:
    name: Server-Side Validation with Temporary Namespace
    runs-on: vollminlab-3
    needs: [validate-changes]
    if: needs.validate-changes.result == 'success' && needs.validate-changes.outputs.changed == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup kubectl
        run: |
          set -euo pipefail
          KUBECTL_VERSION="v${{ env.KUBERNETES_VERSION }}"
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Install yq
        run: |
          set -euo pipefail
          echo "üì¶ Installing yq..."
          sudo curl -L -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Setup Flux CLI
        run: |
          set -euo pipefail
          echo "üì¶ Installing Flux CLI..."
          FLUX_VERSION="2.2.2"
          curl -L "https://github.com/fluxcd/flux2/releases/download/v${FLUX_VERSION}/flux_${FLUX_VERSION}_linux_amd64.tar.gz" -o flux.tar.gz
          tar -xzf flux.tar.gz
          sudo mv flux /usr/local/bin/

      - name: Create test namespace
        run: |
          set -euo pipefail
          TEST_NAMESPACE="ci-test-${{ env.RUN_SUFFIX }}"
          echo "TEST_NAMESPACE=$TEST_NAMESPACE" >> $GITHUB_ENV
          
          kubectl create namespace "$TEST_NAMESPACE" || true
          echo "‚úÖ Created test namespace: $TEST_NAMESPACE"

      - name: Check Flux CRDs
        run: |
          set -euo pipefail
          echo "üîç Checking Flux CRDs availability..."
          
          if ! kubectl get crd ocirepositories.source.toolkit.fluxcd.io >/dev/null 2>&1; then
            echo "‚ö†Ô∏è OCIRepository CRD not found - skipping Flux resource testing"
            echo "FLUX_CRDS_AVAILABLE=false" >> $GITHUB_ENV
            exit 0
          fi
          
          if ! kubectl get crd helmreleases.helm.toolkit.fluxcd.io >/dev/null 2>&1; then
            echo "‚ö†Ô∏è HelmRelease CRD not found - skipping Flux resource testing"
            echo "FLUX_CRDS_AVAILABLE=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "‚úÖ Flux CRDs are available"
          echo "FLUX_CRDS_AVAILABLE=true" >> $GITHUB_ENV

      - name: Test deploy changed resources
        run: |
          set -euo pipefail
          TEST_NAMESPACE="$TEST_NAMESPACE"
          RUN_SUFFIX="${{ env.RUN_SUFFIX }}"
          
          echo "üîç Test deploying changed resources..."
          
          # Get changed files with proper range handling
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
            RANGE="$BASE_SHA..HEAD"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ -z "$BASE_SHA" ]]; then
              BASE_SHA="$(git rev-list --max-parents=0 HEAD | tail -1)"
            fi
            RANGE="$BASE_SHA..HEAD"
          fi
          
          CHANGED_FILES=$(git diff --name-only "$RANGE" | grep -E '\.(yaml|yml)$' | grep '^clusters/' || echo "")
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "‚úÖ No resources to test deploy"
              exit 0
            fi
            
          echo "Changed files: $CHANGED_FILES"
          
          # Create OCI mapping file for Flux resources
          OCI_MAPPING_FILE="/tmp/oci-mapping-$RUN_SUFFIX.txt"
          touch "$OCI_MAPPING_FILE"
          
          # First pass: Deploy OCIRepositories
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && yq eval '.kind' "$file" | grep -qi '^OCIRepository$'; then
              echo "Test deploying OCIRepository: $file"
              
              ORIG_NAME=$(yq eval '.metadata.name' "$file")
              TEST_NAME="test-${ORIG_NAME}-${RUN_SUFFIX}"
              
              echo "$ORIG_NAME:$TEST_NAME" >> "$OCI_MAPPING_FILE"
              
            yq eval "
              .metadata.namespace = \"$TEST_NAMESPACE\" |
                .metadata.name = \"$TEST_NAME\"
            " "$file" | kubectl apply -f - || {
              echo "‚ùå Failed to deploy OCIRepository: $file"
              exit 1
            }
            fi
          done
          
          # Export mapping file for HelmRelease step
          echo "OCI_MAPPING_FILE=$OCI_MAPPING_FILE" >> $GITHUB_ENV
          
          # Wait for OCI repositories to sync (this validates if versions exist)
          echo "‚è≥ Waiting for OCI repositories to sync..."
          echo "This may take 1-5 minutes depending on network conditions and registry response time"
          echo "The sync process downloads chart metadata from remote OCI registries"
          
          # Show initial status
          echo "Current OCI Repository Status:"
          kubectl get ocirepository -n "$TEST_NAMESPACE" -o wide || true
          
          # Wait for OCI repositories to sync with timeout
          echo "Starting OCI repository sync..."
          
          # Use timeout command to ensure we don't wait forever
          timeout 300s bash -c '
            while true; do
              echo "‚è≥ Checking OCI repository status..."
              kubectl get ocirepository -n "$TEST_NAMESPACE" -o wide || true
              
              # Check if all repositories are ready
              if kubectl wait --for=condition=Ready --timeout=10s ocirepositories.source.toolkit.fluxcd.io --all -n "$TEST_NAMESPACE" 2>/dev/null; then
                echo "‚úÖ All OCI repositories are ready"
                exit 0
              fi
              
              # Check for failed conditions - look for any repository with Ready=False or error conditions
              FAILED_REPOS=""
              for repo in $(kubectl get ocirepository -n "$TEST_NAMESPACE" -o name | cut -d/ -f2); do
                # Check if repository has Ready=False condition
                READY_STATUS=$(kubectl get ocirepository "$repo" -n "$TEST_NAMESPACE" -o jsonpath='{.status.conditions[0].status}' 2>/dev/null || echo "")
                READY_REASON=$(kubectl get ocirepository "$repo" -n "$TEST_NAMESPACE" -o jsonpath='{.status.conditions[0].reason}' 2>/dev/null || echo "")
                
                if [[ "$READY_STATUS" == "False" ]] || [[ "$READY_REASON" == *"Failed"* ]] || [[ "$READY_REASON" == *"Error"* ]]; then
                  FAILED_REPOS="$FAILED_REPOS $repo"
                fi
              done
              
              if [[ -n "$FAILED_REPOS" ]]; then
                echo "‚ùå Some OCI repositories have failed: $FAILED_REPOS"
                for repo in $FAILED_REPOS; do
                  echo "--- $repo failure details ---"
                  kubectl describe ocirepository "$repo" -n "$TEST_NAMESPACE" | grep -A 5 -B 5 "Ready\|Failed\|Error" || true
                done
                exit 1
              fi
              
              sleep 30
            done
          ' || {
            echo "‚ùå OCI repositories failed to sync within 5 minutes"
            echo "This indicates that chart versions may not exist or repositories are inaccessible"
            
            # Show detailed status
            echo "OCI Repository Status:"
            kubectl get ocirepository -n "$TEST_NAMESPACE" -o wide
            echo ""
            echo "OCI Repository Details:"
            for repo in $(kubectl get ocirepository -n "$TEST_NAMESPACE" -o name); do
              echo "--- $repo ---"
              kubectl describe "$repo" -n "$TEST_NAMESPACE" | tail -20
            done
            
            echo ""
            echo "üîç Troubleshooting OCI Repository Issues:"
            echo "Common causes:"
            echo "1. Registry temporarily unavailable (tccr.io, ghcr.io, etc.)"
            echo "2. Chart version/tag does not exist"
            echo "3. Network connectivity issues"
            echo "4. Registry authentication required"
            echo ""
            echo "To resolve:"
            echo "- Check if the registry is accessible: curl -I https://tccr.io"
            echo "- Verify the chart version exists in the registry"
            echo "- Check if authentication is required"
            echo "- Consider using a different registry or chart version"
            
            exit 1
          }
          
          echo "‚úÖ Changed OCI repositories synced successfully"

      - name: Deploy and validate changed HelmReleases
        run: |
          set -euo pipefail
          echo "üîç Deploying and validating changed HelmReleases..."
          TEST_NAMESPACE="$TEST_NAMESPACE"
          RUN_SUFFIX="${{ env.RUN_SUFFIX }}"
          
          # Create mapping file if it doesn't exist
          OCI_MAPPING_FILE="/tmp/oci-mapping-$RUN_SUFFIX.txt"
          if [[ ! -f "$OCI_MAPPING_FILE" ]]; then
            touch "$OCI_MAPPING_FILE"
          fi
          
          # Wait for OCIRepositories to be ready before deploying HelmReleases
          if [[ "${FLUX_CRDS_AVAILABLE}" == "true" ]]; then
            echo "‚è≥ Waiting for OCIRepositories to be ready..."
            kubectl wait --for=condition=Ready --timeout=300s ocirepositories.source.toolkit.fluxcd.io --all -n "$TEST_NAMESPACE" || {
              echo "‚ùå OCIRepository sync failed - this would break production deployment"
              echo "üîç Checking OCIRepository status:"
              kubectl get ocirepositories -n "$TEST_NAMESPACE" -o wide
              echo "üìã OCIRepository events:"
              kubectl get events -n "$TEST_NAMESPACE" --field-selector involvedObject.kind=OCIRepository --sort-by='.lastTimestamp'
              exit 1
            }
          fi
          
          # Second pass: Deploy HelmReleases with sourceRef mapping
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && yq eval '.kind' "$file" | grep -qi '^HelmRelease$'; then
              if [[ "${FLUX_CRDS_AVAILABLE}" != "true" ]]; then
                echo "Skipping HelmRelease deploy (Flux CRDs unavailable): $file"
                continue
              fi
              echo "Test deploying HelmRelease: $file"

              if [[ "$(yq eval '.spec.chartRef // ""' "$file")" != "" ]]; then
                ORIG_SOURCE_REF="$(yq eval '.spec.chartRef.name' "$file")"
              else
                ORIG_SOURCE_REF="$(yq eval '.spec.chart.spec.sourceRef.name' "$file")"
              fi

              TEST_SOURCE_REF="$(grep "^${ORIG_SOURCE_REF}:" "$OCI_MAPPING_FILE" | cut -d: -f2 || true)"
              [[ -z "$TEST_SOURCE_REF" ]] && TEST_SOURCE_REF="test-${ORIG_SOURCE_REF}-${RUN_SUFFIX}"

              CLEAN_NAME="$(basename "$file" | sed -E 's/\.(ya?ml)$//' | tr '[:upper:]' '[:lower:]' \
                | sed -E 's/[^a-z0-9-]+/-/g;s/-+/-/g;s/^-|-$//g')"

              if [[ "$(yq eval '.spec.chartRef // ""' "$file")" != "" ]]; then
                yq eval "
                  .metadata.namespace = \"$TEST_NAMESPACE\" |
                  .metadata.name = \"test-${CLEAN_NAME}-${RUN_SUFFIX}\" |
                  .spec.chartRef.name = \"$TEST_SOURCE_REF\" |
                  .spec.chartRef.namespace = \"$TEST_NAMESPACE\"
                " "$file" | kubectl apply -f - || { echo "‚ùå Failed: $file"; exit 1; }
              else
                yq eval "
                  .metadata.namespace = \"$TEST_NAMESPACE\" |
                  .metadata.name = \"test-${CLEAN_NAME}-${RUN_SUFFIX}\" |
                  .spec.chart.spec.sourceRef.name = \"$TEST_SOURCE_REF\" |
                  .spec.chart.spec.sourceRef.namespace = \"$TEST_NAMESPACE\"
                " "$file" | kubectl apply -f - || { echo "‚ùå Failed: $file"; exit 1; }
              fi
            fi
          done
          
          # Third pass: Deploy other namespaced resources (skip cluster-scoped and Flux resources)
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && yq eval '.kind' "$file" | grep -q .; then
              KIND=$(yq eval '.kind' "$file")
              
              # Skip Flux resources (already handled above)
              if [[ "$KIND" == "OCIRepository" || "$KIND" == "HelmRelease" ]]; then
                continue
              fi
              
              # Skip cluster-scoped resources and Kustomization (CRD not available in test namespace)
              case "$KIND" in
                ClusterRole|ClusterRoleBinding|ClusterPolicy|ClusterPolicyReport|CustomResourceDefinition|Namespace|Node|PersistentVolume|StorageClass|ValidatingAdmissionWebhook|MutatingAdmissionWebhook|Kustomization)
                  echo "Skipping $KIND resource: $file"
                  continue
                  ;;
              esac
              
              echo "Test deploying namespaced resource: $file"
              
              # Clean filename for DNS-1123 compliance
              CLEAN_NAME="$(basename "$file" | sed -E 's/\.(ya?ml)$//' | tr '[:upper:]' '[:lower:]' \
                | sed -E 's/[^a-z0-9-]+/-/g;s/-+/-/g;s/^-|-$//g')"
              
            yq eval "
              .metadata.namespace = \"$TEST_NAMESPACE\" |
                .metadata.name = \"test-${CLEAN_NAME}-${RUN_SUFFIX}\"
            " "$file" | kubectl apply -f - || {
                echo "‚ùå Failed to deploy: $file"
              exit 1
            }
            fi
          done
          
          echo "‚úÖ Successfully test deployed all changed resources"

      - name: Wait for deployments
        run: |
          set -euo pipefail
          TEST_NAMESPACE="$TEST_NAMESPACE"
          
          echo "‚è≥ Waiting for deployments to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment --all -n "$TEST_NAMESPACE" || {
            echo "‚ö†Ô∏è Some deployments may not be ready, but continuing..."
          }

      - name: Cleanup test namespace
        if: always()
        run: |
          set -euo pipefail
          TEST_NAMESPACE="$TEST_NAMESPACE"
          
          echo "üßπ Cleaning up test namespace..."
            kubectl delete namespace "$TEST_NAMESPACE" --ignore-not-found=true
          echo "‚úÖ Cleaned up test namespace: $TEST_NAMESPACE"

  security-scan:
    name: Security Scan
    runs-on: vollminlab-1
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare Trivy cache
        run: mkdir -p "${{ env.TRIVY_CACHE_DIR }}"

      - name: Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'HIGH,CRITICAL'
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}

      - name: Run Trivy IaC scan
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'config'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-config-results.sarif'
          severity: 'HIGH,CRITICAL'
          cache-dir: ${{ env.TRIVY_CACHE_DIR }}

      - name: Upload Trivy filesystem SARIF results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-fs'
          
      - name: Upload Trivy IaC SARIF results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-config-results.sarif'
          category: 'trivy-config'

  policy-validation:
    name: Kyverno Policy Validation
    runs-on: vollminlab-1
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install kyverno CLI
        run: |
          set -euo pipefail
          echo "üì¶ Installing Kyverno CLI..."
          curl -L "https://github.com/kyverno/kyverno/releases/download/v1.12.1/kyverno-cli_v1.12.1_linux_x86_64.tar.gz" -o kyverno.tar.gz
          tar -xzf kyverno.tar.gz
          sudo mv kyverno /usr/local/bin/
          kyverno version

      - name: Validate against Kyverno policies
        run: |
          set -euo pipefail
          echo "üîç Validating resources against Kyverno policies..."
          
          # Get changed files with proper range handling
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            RANGE="$BASE_SHA..HEAD"
          else
            BASE_SHA="${{ github.event.before }}"
            if [[ -z "$BASE_SHA" ]]; then
              BASE_SHA="$(git rev-list --max-parents=0 HEAD | tail -1)"
            fi
            RANGE="$BASE_SHA..HEAD"
          fi
          
          CHANGED_FILES=$(git diff --name-only "$RANGE" | grep -E '\.(yaml|yml)$' | grep '^clusters/' || echo "")
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "‚úÖ No files to validate against policies"
            exit 0
          fi
          
          # Find policy files by parsing 'kind' for each document (handles multi-doc YAML)
          mapfile -t POLICY_FILES < <(
            git ls-files 'clusters/**/kyverno/**/*.ya?ml' \
            | while IFS= read -r f; do
                # handle multi-doc YAMLs
                if yq eval-all '.[].kind' "$f" | grep -Eq '^(Policy|ClusterPolicy)$'; then
                  echo "$f"
            fi
          done
          )
          
          if (( ${#POLICY_FILES[@]} == 0 )); then
            echo "‚ö†Ô∏è No Kyverno Policy/ClusterPolicy documents found"
            exit 0
          fi
          
          # Validate only the changed resource files
          for file in $CHANGED_FILES; do
            [[ -f "$file" ]] || continue
            # Skip Flux kinds if policies don't target them
            if yq eval '.kind' "$file" | grep -Eq '^(HelmRelease|OCIRepository)$'; then
              echo "Skipping Flux resource (not targeted by policies): $file"
              continue
            fi
            
            echo "Validating: $file"
            args=()
            for p in "${POLICY_FILES[@]}"; do args+=(-f "$p"); done
            kyverno apply "${args[@]}" --resource "$file" || {
              echo "‚ùå Policy validation failed for $file"
            exit 1
          }
          done
          
          echo "‚úÖ All resources comply with Kyverno policies"
          
  integration-test:
    name: Integration Test
    runs-on: vollminlab-2
    needs: [validate-changes, test-deployment, security-scan, policy-validation]
    if: always() && needs.security-scan.result == 'success' && needs.policy-validation.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Integration test placeholder
        run: |
          set -euo pipefail
          echo "üß™ Running integration tests..."
          echo "‚úÖ Integration tests passed!"
          echo "üìã All components are working correctly together"

  notify-success:
    name: Notify Success
    runs-on: vollminlab-3
    needs: [validate-changes, test-deployment, security-scan, policy-validation, integration-test]
    if: success()
    steps:
      - name: Success notification
        run: |
          set -euo pipefail
          echo "‚úÖ All CI checks passed!"
          echo "üöÄ Ready for deployment"

  notify-failure:
    name: Notify Failure
    runs-on: vollminlab-3
    needs: [validate-changes, test-deployment, security-scan, policy-validation, integration-test]
    if: failure()
    steps:
      - name: Failure notification
        run: |
          set -euo pipefail
          echo "‚ùå CI checks failed!"
          echo "üîß Please review the failed steps above"