name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  KUBERNETES_VERSION: "1.32.3"

jobs:
  validate-manifests:
    name: Validate Kubernetes Manifests
    runs-on: vollminlab
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          echo "üì¶ Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/v${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Validate YAML syntax
        run: |
          echo "üîç Validating YAML syntax..."
          # Use kubectl to validate YAML syntax for Kubernetes resources only
          find clusters -name "*.yaml" -o -name "*.yml" | while read file; do
            # Skip kustomization files (build files, not Kubernetes resources)
            if [[ "$file" == *"kustomization.yaml" ]]; then
              echo "Skipping $file (Kustomization build file)"
              continue
            fi
            # Skip resources that require missing CRDs (temporary workaround)
            if [[ "$file" == *"flux-exception.yaml" ]]; then
              echo "Skipping $file (requires PolicyException CRD)"
              continue
            fi
            echo "Validating $file"
            kubectl apply --dry-run=client -f "$file" || {
              echo "‚ùå Invalid YAML syntax in $file"
              echo "Error details:"
              kubectl apply --dry-run=client -f "$file" 2>&1 || true
              exit 1
            }
          done
          echo "‚úÖ All YAML files have valid syntax"

      - name: Validate Kubernetes manifests
        run: |
          echo "üîç Validating Kubernetes manifests..."
          find clusters -name "*.yaml" -o -name "*.yml" | while read file; do
            # Skip kustomization files (build files, not Kubernetes resources)
            if [[ "$file" == *"kustomization.yaml" ]]; then
              echo "Skipping $file (Kustomization build file)"
              continue
            fi
            # Skip resources that require missing CRDs (temporary workaround)
            if [[ "$file" == *"flux-exception.yaml" ]]; then
              echo "Skipping $file (requires PolicyException CRD)"
              continue
            fi
            echo "Validating $file"
            kubectl apply --dry-run=client -f "$file" || exit 1
          done

      - name: Check for common issues
        run: |
          echo "üîç Checking for common issues..."
          
          # Check for hardcoded secrets (exclude SealedSecrets and legitimate references)
          # First, find files with password fields
          for file in $(find clusters -name "*.yaml" -o -name "*.yml" | xargs grep -l "password\s*:"); do
            # Skip if it's a SealedSecret or legitimate reference
            if grep -q "kind: SealedSecret\|encryptedData:" "$file"; then
              echo "Skipping $file (SealedSecret)"
              continue
            fi
            # Check for actual hardcoded secrets (not in SealedSecret context)
            if grep "password\s*:\s*[a-zA-Z0-9]" "$file" | grep -v "encryptedData:\|spec:"; then
              echo "‚ùå Found potential hardcoded secrets in $file"
              exit 1
            fi
          done
          
          # Check for missing labels
          echo "‚úÖ No hardcoded secrets found"

  server-side-validation:
    name: Server-Side Validation with Temporary Namespace
    runs-on: vollminlab
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          echo "üì¶ Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/v${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Setup Flux CLI
        run: |
          curl -s https://fluxcd.io/install.sh | sudo bash

      - name: Install yq
        run: |
          echo "üì¶ Installing yq for YAML validation..."
          sudo curl -L -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Create temporary testing namespace
        run: |
          echo "üß™ Creating temporary testing namespace..."
          TEST_NAMESPACE="ci-test-$(date +%s)-${GITHUB_RUN_ID:-$(whoami)}"
          echo "TEST_NAMESPACE=$TEST_NAMESPACE" >> $GITHUB_ENV
          kubectl create namespace "$TEST_NAMESPACE"
          echo "‚úÖ Created namespace: $TEST_NAMESPACE"

      - name: Deploy and validate OCI repositories
        run: |
          echo "üîç Deploying and validating OCI repositories..."
          TEST_NAMESPACE="$TEST_NAMESPACE"
          
          # Deploy all OCI repositories to test namespace
          for file in $(find clusters -name "*helmrepository.yaml" -exec grep -l "kind: OCIRepository" {} \;); do
            echo "Deploying OCIRepository: $file"
            
            # Create a modified version for the test namespace
            sed "s/namespace: flux-system/namespace: $TEST_NAMESPACE/g" "$file" | \
            sed "s/name: .*/name: test-$(basename "$file" .yaml)-$(date +%s)/g" | \
            kubectl apply -f - || {
              echo "‚ùå Failed to deploy OCIRepository: $file"
              exit 1
            }
          done
          
          # Wait for OCI repositories to sync (this validates if versions exist)
          echo "‚è≥ Waiting for OCI repositories to sync..."
          kubectl wait --for=condition=Ready --timeout=300s ocirepository --all -n "$TEST_NAMESPACE" || {
            echo "‚ùå OCI repositories failed to sync"
            echo "This indicates that chart versions may not exist or repositories are inaccessible"
            
            # Show detailed status
            echo "OCI Repository Status:"
            kubectl get ocirepository -n "$TEST_NAMESPACE" -o wide
            echo ""
            echo "OCI Repository Details:"
            for repo in $(kubectl get ocirepository -n "$TEST_NAMESPACE" -o name); do
              echo "--- $repo ---"
              kubectl describe "$repo" -n "$TEST_NAMESPACE" | tail -20
            done
            exit 1
          }
          
          echo "‚úÖ All OCI repositories synced successfully"

      - name: Deploy and validate HelmReleases
        run: |
          echo "üîç Deploying and validating HelmReleases..."
          TEST_NAMESPACE="$TEST_NAMESPACE"
          
          # Deploy all HelmReleases to test namespace
          for file in $(find clusters -name "helmrelease.yaml"); do
            echo "Deploying HelmRelease: $file"
            
            # Create a modified version for the test namespace
            # Replace namespace and update chart references to use test repositories
            sed "s/namespace: [a-zA-Z0-9-]*/namespace: $TEST_NAMESPACE/g" "$file" | \
            sed "s/name: [a-zA-Z0-9-]*/name: test-$(basename "$(dirname "$file")")-$(date +%s)/g" | \
            sed "s/name: [a-zA-Z0-9-]*-helmrepository/name: test-\1-helmrepository/g" | \
            kubectl apply -f - || {
              echo "‚ùå Failed to deploy HelmRelease: $file"
              exit 1
            }
          done
          
          # Wait for HelmReleases to be ready (this validates if charts can be deployed)
          echo "‚è≥ Waiting for HelmReleases to be ready..."
          kubectl wait --for=condition=Ready --timeout=600s helmrelease --all -n "$TEST_NAMESPACE" || {
            echo "‚ùå HelmReleases failed to become ready"
            echo "This indicates that chart deployments are failing"
            
            # Show detailed status
            echo "HelmRelease Status:"
            kubectl get helmrelease -n "$TEST_NAMESPACE" -o wide
            echo ""
            echo "HelmRelease Details:"
            for hr in $(kubectl get helmrelease -n "$TEST_NAMESPACE" -o name); do
              echo "--- $hr ---"
              kubectl describe "$hr" -n "$TEST_NAMESPACE" | tail -20
            done
            exit 1
          }
          
          echo "‚úÖ All HelmReleases are ready"

      - name: Validate deployments are working
        run: |
          echo "üîç Validating that deployments are actually working..."
          TEST_NAMESPACE="$TEST_NAMESPACE"
          
          # Wait for all deployments to be ready
          echo "‚è≥ Waiting for deployments to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment --all -n "$TEST_NAMESPACE" || {
            echo "‚ùå Some deployments failed to become available"
            echo "Deployment Status:"
            kubectl get deployments -n "$TEST_NAMESPACE"
            echo ""
            echo "Pod Status:"
            kubectl get pods -n "$TEST_NAMESPACE"
            echo ""
            echo "Pod Details (failed pods):"
            for pod in $(kubectl get pods -n "$TEST_NAMESPACE" --field-selector=status.phase!=Running -o name); do
              echo "--- $pod ---"
              kubectl describe "$pod" -n "$TEST_NAMESPACE" | tail -20
            done
            exit 1
          }
          
          # Check that all pods are running
          FAILED_PODS=$(kubectl get pods -n "$TEST_NAMESPACE" --field-selector=status.phase!=Running --no-headers | wc -l)
          if [[ "$FAILED_PODS" -gt 0 ]]; then
            echo "‚ùå Found $FAILED_PODS pods that are not running"
            kubectl get pods -n "$TEST_NAMESPACE"
            exit 1
          fi
          
          echo "‚úÖ All deployments are running successfully"

      - name: Cleanup temporary namespace
        if: always()
        run: |
          echo "üßπ Cleaning up temporary namespace..."
          TEST_NAMESPACE="$TEST_NAMESPACE"
          if [[ -n "$TEST_NAMESPACE" ]]; then
            kubectl delete namespace "$TEST_NAMESPACE" --ignore-not-found=true
            echo "‚úÖ Cleaned up namespace: $TEST_NAMESPACE"
          fi

  security-scan:
    name: Security Scan
    runs-on: vollminlab
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        timeout-minutes: 3
        continue-on-error: true
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always() && !cancelled()
        timeout-minutes: 1
        continue-on-error: true
        with:
          sarif_file: 'trivy-results.sarif'
          
      - name: Display Trivy results if upload fails
        if: failure()
        run: |
          echo "‚ö†Ô∏è SARIF upload failed, but Trivy scan completed successfully"
          echo "üìä Security scan results are still valuable for local review"
          echo "üîç Check the Trivy output above for security findings"

  flux-validation:
    name: Flux Configuration Validation
    runs-on: vollminlab
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          echo "üì¶ Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/v${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Setup Flux CLI
        run: |
          curl -s https://fluxcd.io/install.sh | sudo bash

      - name: Install yq
        run: |
          echo "üì¶ Installing yq for YAML validation..."
          sudo curl -L -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Validate Flux configurations
        run: |
          echo "üîç Validating Flux configurations..."
          
          # Check Kustomizations using kubectl kustomize
          KUSTOMIZATION_COUNT=0
          for file in $(find clusters -name "kustomization.yaml"); do
            echo "Validating Kustomization: $file"
            kubectl kustomize "$(dirname "$file")" >/dev/null 2>&1 || {
              echo "‚ùå Failed to validate Kustomization: $file"
              exit 1
            }
            KUSTOMIZATION_COUNT=$((KUSTOMIZATION_COUNT + 1))
          done
          echo "‚úÖ Validated $KUSTOMIZATION_COUNT Kustomizations"
          
          # Check HelmReleases
          HELMRELEASE_COUNT=0
          for file in $(find clusters -name "helmrelease.yaml"); do
            echo "Validating HelmRelease: $file"
            
            # Client-side validation
            kubectl apply --dry-run=client -f "$file" || {
              echo "‚ùå Failed to validate HelmRelease: $file"
              echo "Error details:"
              kubectl apply --dry-run=client -f "$file" 2>&1 || true
              exit 1
            }
            
            # Check if HelmRelease references a specific chart version
            CHART_VERSION=$(yq eval '.spec.chart.spec.version // .spec.chartRef.version' "$file" 2>/dev/null || echo "")
            if [[ -n "$CHART_VERSION" ]]; then
              echo "üîç HelmRelease references specific chart version: $CHART_VERSION"
              echo "‚ÑπÔ∏è  Chart version will be validated by server-side validation"
            fi
            
            HELMRELEASE_COUNT=$((HELMRELEASE_COUNT + 1))
          done
          echo "‚úÖ Validated $HELMRELEASE_COUNT HelmReleases"
          
          # Check all Flux CD Repository types
          REPO_COUNT=0
          for file in $(find clusters -name "*helmrepository.yaml"); do
            if grep -q "kind: OCIRepository" "$file"; then
              echo "Validating OCIRepository: $file"
              
              # Client-side validation
              kubectl apply --dry-run=client -f "$file" || {
                echo "‚ùå Failed to validate OCIRepository: $file"
                echo "Error details:"
                kubectl apply --dry-run=client -f "$file" 2>&1 || true
                exit 1
              }
              
              echo "‚ÑπÔ∏è  OCI repository will be validated by server-side validation"
            else
              echo "Validating HelmRepository: $file"
              
              # Client-side validation
              kubectl apply --dry-run=client -f "$file" || {
                echo "‚ùå Failed to validate HelmRepository: $file"
                echo "Error details:"
                kubectl apply --dry-run=client -f "$file" 2>&1 || true
                exit 1
              }
              
              # Check if this HelmRepository uses OCI URLs (some do)
              REPO_URL=$(yq eval '.spec.url' "$file")
              if [[ "$REPO_URL" == oci://* ]]; then
                echo "üîç HelmRepository uses OCI URL - checking if repository is accessible..."
                # For OCI Helm repositories, we can't easily validate specific tags without knowing the chart structure
                # But we can at least check if the repository is accessible
                REGISTRY_URL="${REPO_URL#oci://}"
                CATALOG_URL="https://${REGISTRY_URL}/v2/_catalog"
                
                echo "Checking catalog at: $CATALOG_URL"
                HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$CATALOG_URL")
                
                if [[ "$HTTP_STATUS" == "200" ]]; then
                  echo "‚úÖ OCI HelmRepository is accessible"
                elif [[ "$HTTP_STATUS" == "404" ]]; then
                  echo "‚ùå OCI HelmRepository $REPO_URL is not accessible"
                  exit 1
                else
                  echo "‚ö†Ô∏è  Could not verify OCI HelmRepository $REPO_URL (HTTP $HTTP_STATUS). Repository may require authentication."
                  echo "Continuing with validation, but please verify manually."
                fi
              fi
              
              # For regular Helm repositories, check if the repository is accessible
              if [[ "$REPO_URL" != oci://* ]]; then
                echo "üîç Checking if Helm repository is accessible..."
                echo "Repository URL: $REPO_URL"
                # For HTTP/HTTPS repositories, we can check if they're accessible
                if [[ "$REPO_URL" == http* ]]; then
                  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$REPO_URL")
                  if [[ "$HTTP_STATUS" == "200" ]]; then
                    echo "‚úÖ HelmRepository is accessible"
                  elif [[ "$HTTP_STATUS" == "404" ]]; then
                    echo "‚ùå HelmRepository $REPO_URL is not accessible"
                    exit 1
                  else
                    echo "‚ö†Ô∏è  Could not verify HelmRepository $REPO_URL (HTTP $HTTP_STATUS)"
                    echo "Continuing with validation, but please verify manually."
                  fi
                fi
              fi
            fi
            REPO_COUNT=$((REPO_COUNT + 1))
          done
          echo "‚úÖ Validated $REPO_COUNT Repository manifests"
          
          # Check all container image tags in Kubernetes resources
          echo "üîç Validating container image tags..."
          IMAGE_VALIDATION_COUNT=0
          for file in $(find clusters -name "*.yaml" -exec grep -l "image:" {} \;); do
            echo "Checking image tags in: $file"
            
            # Extract all image references
            IMAGES=$(yq eval '.. | select(has("image")) | .image' "$file" 2>/dev/null | grep -v "null" | sort -u)
            
            for IMAGE in $IMAGES; do
              if [[ -n "$IMAGE" && "$IMAGE" != "null" ]]; then
                echo "  Checking image: $IMAGE"
                
                # Parse image name and tag
                if [[ "$IMAGE" == *":"* ]]; then
                  IMAGE_NAME="${IMAGE%:*}"
                  IMAGE_TAG="${IMAGE##*:}"
                else
                  IMAGE_NAME="$IMAGE"
                  IMAGE_TAG="latest"
                fi
                
                # Skip if it's a local image or doesn't look like a registry image
                if [[ "$IMAGE_NAME" == *"localhost"* ]] || [[ "$IMAGE_NAME" == *"127.0.0.1"* ]] || [[ ! "$IMAGE_NAME" == *"."* ]]; then
                  echo "    ‚è≠Ô∏è  Skipping local/unqualified image: $IMAGE"
                  continue
                fi
                
                # For Docker Hub images
                if [[ "$IMAGE_NAME" == *"docker.io"* ]] || [[ "$IMAGE_NAME" != *"/"* ]] || [[ "$IMAGE_NAME" == *"library"* ]]; then
                  # Convert to Docker Hub format
                  if [[ "$IMAGE_NAME" == *"docker.io"* ]]; then
                    DOCKER_IMAGE="$IMAGE_NAME"
                  elif [[ "$IMAGE_NAME" != *"/"* ]]; then
                    DOCKER_IMAGE="docker.io/library/$IMAGE_NAME"
                  else
                    DOCKER_IMAGE="docker.io/$IMAGE_NAME"
                  fi
                  
                  MANIFEST_URL="https://registry-1.docker.io/v2/${DOCKER_IMAGE#docker.io/}/manifests/${IMAGE_TAG}"
                  
                  echo "    Checking Docker Hub manifest: $MANIFEST_URL"
                  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Accept: application/vnd.docker.distribution.manifest.v2+json" "$MANIFEST_URL")
                  
                  if [[ "$HTTP_STATUS" == "200" ]]; then
                    echo "    ‚úÖ Image tag $IMAGE_TAG exists"
                  elif [[ "$HTTP_STATUS" == "404" ]]; then
                    echo "    ‚ùå Image tag $IMAGE_TAG does not exist for $IMAGE_NAME"
                    echo "    Please verify the image tag exists in the registry"
                    exit 1
                  else
                    echo "    ‚ö†Ô∏è  Could not verify image tag $IMAGE_TAG (HTTP $HTTP_STATUS)"
                    echo "    Continuing with validation, but please verify manually"
                  fi
                else
                  # For other registries (GHCR, Quay, etc.)
                  REGISTRY_DOMAIN=$(echo "$IMAGE_NAME" | cut -d'/' -f1)
                  IMAGE_PATH="${IMAGE_NAME#*/}"
                  
                  MANIFEST_URL="https://$REGISTRY_DOMAIN/v2/$IMAGE_PATH/manifests/$IMAGE_TAG"
                  
                  echo "    Checking registry manifest: $MANIFEST_URL"
                  HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Accept: application/vnd.docker.distribution.manifest.v2+json" "$MANIFEST_URL")
                  
                  if [[ "$HTTP_STATUS" == "200" ]]; then
                    echo "    ‚úÖ Image tag $IMAGE_TAG exists"
                  elif [[ "$HTTP_STATUS" == "404" ]]; then
                    echo "    ‚ùå Image tag $IMAGE_TAG does not exist for $IMAGE_NAME"
                    echo "    Please verify the image tag exists in the registry"
                    exit 1
                  else
                    echo "    ‚ö†Ô∏è  Could not verify image tag $IMAGE_TAG (HTTP $HTTP_STATUS)"
                    echo "    Registry may require authentication or have different access patterns"
                    echo "    Continuing with validation, but please verify manually"
                  fi
                fi
                
                IMAGE_VALIDATION_COUNT=$((IMAGE_VALIDATION_COUNT + 1))
              fi
            done
          done
          echo "‚úÖ Validated $IMAGE_VALIDATION_COUNT container image tags"
          
          # Check Flux CD Kustomizations
          FLUX_KUSTOMIZATION_COUNT=0
          for file in $(find clusters -name "*-kustomization.yaml"); do
            echo "Validating Flux Kustomization: $file"
            kubectl apply --dry-run=client -f "$file" || {
              echo "‚ùå Failed to validate Flux Kustomization: $file"
              echo "Error details:"
              kubectl apply --dry-run=client -f "$file" 2>&1 || true
              exit 1
            }
            FLUX_KUSTOMIZATION_COUNT=$((FLUX_KUSTOMIZATION_COUNT + 1))
          done
          echo "‚úÖ Validated $FLUX_KUSTOMIZATION_COUNT Flux Kustomizations"
          
          # Check SealedSecrets
          SEALEDSECRET_COUNT=0
          for file in $(find clusters -name "*sealedsecret*.yaml"); do
            echo "Validating SealedSecret: $file"
            kubectl apply --dry-run=client -f "$file" || {
              echo "‚ùå Failed to validate SealedSecret: $file"
              echo "Error details:"
              kubectl apply --dry-run=client -f "$file" 2>&1 || true
              exit 1
            }
            SEALEDSECRET_COUNT=$((SEALEDSECRET_COUNT + 1))
          done
          echo "‚úÖ Validated $SEALEDSECRET_COUNT SealedSecrets"
          
          # Check GitRepositories
          GITREPO_COUNT=0
          for file in $(find clusters -name "*.yaml" -exec grep -l "kind: GitRepository" {} \;); do
            echo "Validating GitRepository: $file"
            kubectl apply --dry-run=client -f "$file" || {
              echo "‚ùå Failed to validate GitRepository: $file"
              echo "Error details:"
              kubectl apply --dry-run=client -f "$file" 2>&1 || true
              exit 1
            }
            GITREPO_COUNT=$((GITREPO_COUNT + 1))
          done
          echo "‚úÖ Validated $GITREPO_COUNT GitRepositories"
          
          # Check RunnerDeployments (Actions Runner Controller)
          RUNNERDEPLOYMENT_COUNT=0
          for file in $(find clusters -name "*.yaml" -exec grep -l "kind: RunnerDeployment" {} \;); do
            echo "Validating RunnerDeployment: $file"
            kubectl apply --dry-run=client -f "$file" || {
              echo "‚ùå Failed to validate RunnerDeployment: $file"
              echo "Error details:"
              kubectl apply --dry-run=client -f "$file" 2>&1 || true
              exit 1
            }
            RUNNERDEPLOYMENT_COUNT=$((RUNNERDEPLOYMENT_COUNT + 1))
          done
          echo "‚úÖ Validated $RUNNERDEPLOYMENT_COUNT RunnerDeployments"
          
          # Check Kyverno Policies (pure YAML validation - no kubectl server interaction)
          KYVERNO_POLICY_COUNT=0
          for file in $(find clusters -name "*.yaml" -exec grep -l "kind: ClusterPolicy\|kind: PolicyException" {} \;); do
            echo "Validating Kyverno Policy YAML syntax: $file"
            # Use yq or python to validate YAML syntax without kubectl
            if command -v yq >/dev/null 2>&1; then
              yq eval '.' "$file" >/dev/null || {
                echo "‚ùå Failed to validate Kyverno Policy YAML syntax: $file"
                exit 1
              }
            else
              # Fallback to python for YAML validation
              python3 -c "import yaml; yaml.safe_load_all(open('$file'))" || {
                echo "‚ùå Failed to validate Kyverno Policy YAML syntax: $file"
                exit 1
              }
            fi
            KYVERNO_POLICY_COUNT=$((KYVERNO_POLICY_COUNT + 1))
          done
          echo "‚úÖ Validated $KYVERNO_POLICY_COUNT Kyverno Policies (YAML syntax)"
          
          # Check Kubernetes native resources
          NATIVE_RESOURCE_COUNT=0
          for file in $(find clusters -name "*.yaml" -exec grep -l "kind: ConfigMap\|kind: Ingress\|kind: PersistentVolumeClaim\|kind: ServiceAccount\|kind: ClusterRole\|kind: ClusterRoleBinding" {} \;); do
            echo "Validating Kubernetes native resource: $file"
            kubectl apply --dry-run=client -f "$file" || {
              echo "‚ùå Failed to validate Kubernetes resource: $file"
              echo "Error details:"
              kubectl apply --dry-run=client -f "$file" 2>&1 || true
              exit 1
            }
            NATIVE_RESOURCE_COUNT=$((NATIVE_RESOURCE_COUNT + 1))
          done
          echo "‚úÖ Validated $NATIVE_RESOURCE_COUNT Kubernetes native resources"
          
          # Validate metadata consistency
          echo "üîç Validating metadata consistency..."
          
          # Check for consistent labels in Flux CD resources
          for file in $(find clusters -name "*.yaml" -exec grep -l "kind: HelmRelease\|kind: OCIRepository\|kind: HelmRepository" {} \;); do
            if ! grep -q "app:" "$file" || ! grep -q "env: production" "$file" || ! grep -q "category:" "$file"; then
              echo "‚ùå Missing required labels in Flux CD resource: $file"
              echo "Required labels: app, env: production, category"
              exit 1
            fi
          done
          
          # Check for consistent namespace usage
          echo "üîç Validating namespace consistency..."
          for file in $(find clusters -name "*.yaml" -exec grep -l "kind: HelmRelease" {} \;); do
            namespace=$(grep "namespace:" "$file" | head -1 | awk '{print $2}')
            app_name=$(grep "name:" "$file" | head -1 | awk '{print $2}')
            if [[ "$namespace" != "$app_name" ]]; then
              echo "‚ö†Ô∏è  Namespace mismatch in HelmRelease: $file (namespace: $namespace, name: $app_name)"
              echo "Consider if this is intentional"
            fi
          done
          
          # Check for consistent storage class usage
          echo "üîç Validating storage class consistency..."
          for file in $(find clusters -name "*pvc*.yaml"); do
            if ! grep -q "storageClassName: smb" "$file"; then
              echo "‚ö†Ô∏è  PVC not using SMB storage class: $file"
              echo "Consider using 'storageClassName: smb' for consistency"
            fi
          done
          
          echo "‚úÖ Metadata consistency validation completed"

  policy-validation:
    name: Kyverno Policy Validation
    runs-on: vollminlab
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          echo "üì¶ Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/v${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Setup Kyverno CLI
        run: |
          # Install Kyverno CLI using GitHub releases
          echo "üì¶ Installing Kyverno CLI..."
          KYVERNO_VERSION=$(curl -s https://api.github.com/repos/kyverno/kyverno/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          echo "Installing Kyverno CLI version: $KYVERNO_VERSION"
          curl -L "https://github.com/kyverno/kyverno/releases/download/${KYVERNO_VERSION}/kyverno-cli_${KYVERNO_VERSION}_linux_x86_64.tar.gz" | tar -xz
          sudo mv kyverno /usr/local/bin/
          kyverno version

      - name: Validate Kyverno policies
        run: |
          echo "üîç Validating Kyverno policies..."
          POLICY_COUNT=0
          for file in $(find clusters -name "*.yaml" -path "*/kyverno/*"); do
            # Skip PolicyException files as they require Kyverno operator to be installed
            if [[ "$file" == *"flux-exception.yaml" ]]; then
              echo "Skipping $file (PolicyException requires Kyverno operator)"
              continue
            fi
            if grep -q "kind: Policy\|kind: ClusterPolicy" "$file"; then
              echo "Validating Kyverno policy syntax: $file"
              kubectl apply --dry-run=client -f "$file" || {
                echo "‚ùå Failed to validate Kyverno policy: $file"
                echo "Error details:"
                kubectl apply --dry-run=client -f "$file" 2>&1 || true
                exit 1
              }
              POLICY_COUNT=$((POLICY_COUNT + 1))
            fi
          done
          echo "‚úÖ Validated $POLICY_COUNT Kyverno policies"

  notify-success:
    name: Notify Success
    runs-on: vollminlab
    needs: [validate-manifests, server-side-validation, security-scan, flux-validation, policy-validation]
    if: success()
    steps:
      - name: Success notification
        run: |
          echo "‚úÖ All CI checks passed!"
          echo "üöÄ Ready for deployment"
          echo "üìä Server-side validation confirmed all OCI repositories and HelmReleases work correctly"

  notify-failure:
    name: Notify Failure
    runs-on: vollminlab
    needs: [validate-manifests, server-side-validation, security-scan, flux-validation, policy-validation]
    if: failure()
    steps:
      - name: Failure notification
        run: |
          echo "‚ùå CI checks failed!"
          echo "üîß Please review the failed steps above"
          echo "üí° Server-side validation provides detailed error information for debugging"