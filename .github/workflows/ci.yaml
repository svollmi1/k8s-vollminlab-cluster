name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'clusters/**'
      - '.github/workflows/**'
      - 'terraform/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'clusters/**'
      - '.github/workflows/**'
      - 'terraform/**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  security-events: write

env:
  KUBERNETES_VERSION: "1.30.2"
  RUN_SUFFIX: ${{ github.run_id }}-${{ github.run_number }}
  TRIVY_CACHE_DIR: .trivy-cache

jobs:
  validate-changes:
    name: Validate Kubernetes Manifests
    runs-on: vollminlab-1
    outputs:
      changed-files-b64: ${{ steps.get-changed-files.outputs.changed-files-b64 }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install kubectl
        run: |
          set -euo pipefail
          echo "üì¶ Installing kubectl..."
          KUBECTL_VERSION="v${{ env.KUBERNETES_VERSION }}"
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          kubectl version --client

      - name: Install yq
        run: |
          echo "üì¶ Installing yq..."
          sudo curl -L -o /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Get changed files
        id: get-changed-files
        run: |
          set -euo pipefail
          echo "üîç Finding changed files..."
          
          # Handle both PR and push events correctly
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            RANGE="${{ github.event.pull_request.base.sha }}..${{ github.sha }}"
          else
            RANGE="${{ github.event.before }}..${{ github.sha }}"
          fi
          
          CHANGED_FILES=$(git diff --name-only "$RANGE" | grep -E '^(clusters/).*\.(ya?ml)$' || true)
          
          echo "All changed files:"
          git diff --name-only "$RANGE"
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "‚úÖ No YAML files changed in clusters directory"
            echo "changed-files=" >> $GITHUB_OUTPUT
            echo "CHANGED_FILES=" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "Changed YAML files in clusters/: $CHANGED_FILES"
          
          # Use base64 encoding to safely pass multi-line data
          CHANGED_FILES_B64=$(echo "$CHANGED_FILES" | base64 -w 0)
          echo "changed-files-b64=$CHANGED_FILES_B64" >> $GITHUB_OUTPUT
          
          # Also set as environment variable for current job
          echo "CHANGED_FILES<<EOF" >> $GITHUB_ENV
          echo "$CHANGED_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Install yamllint
        run: |
          set -euo pipefail
          echo "üì¶ Installing yamllint..."
          sudo apt-get update
          sudo apt-get install -y yamllint
          yamllint --version

      - name: Validate YAML syntax and structure
        if: env.CHANGED_FILES != ''
        run: |
          set -euo pipefail
          echo "üîç Validating YAML syntax and structure..."
          
          # Create yamllint config for Kubernetes files
          cat > .yamllint << 'EOF'
          extends: default
          
          rules:
            document-start:
              present: false  # Don't require --- at start
            new-line-at-end-of-file:
              level: warning  # Make it a warning, not error
            line-length:
              max: 200  # Allow longer lines for Kubernetes (was 120)
              level: warning  # Make it a warning, not error
            indentation:
              spaces: 2
              indent-sequences: true
            truthy:
              allowed-values: ['true', 'false', 'yes', 'no']
            comments:
              min-spaces-from-content: 1
          EOF
          
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]]; then
              echo "Validating: $file"
              
              # Run yamllint but don't fail on warnings
              yamllint -c .yamllint "$file" || {
                echo "‚ö†Ô∏è YAML lint warnings in $file (continuing)"
              }
              
              # Only fail on actual syntax errors
              yq eval '.' "$file" > /dev/null || {
                echo "‚ùå YAML syntax error in $file"
            exit 1
          }
            fi
          done
          
          echo "‚úÖ All YAML files have valid syntax and structure"

      - name: Validate required labels on CHANGED Flux resources
        if: env.CHANGED_FILES != ''
        run: |
          set -euo pipefail
          echo "üîç Validating required labels on CHANGED Flux resources only..."
          
          echo "DEBUG: CHANGED_FILES variable: '$CHANGED_FILES'"
          echo "DEBUG: CHANGED_FILES length: ${#CHANGED_FILES}"
          
          # Determine expected env based on branch
          EXPECTED_ENV="production"
          if [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            EXPECTED_ENV="staging"
          fi
          
          echo "DEBUG: Expected env: $EXPECTED_ENV"
          
          CHANGED_FLUX_FILES=""
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && grep -q "kind: HelmRelease\|kind: OCIRepository\|kind: HelmRepository" "$file"; then
              CHANGED_FLUX_FILES="$CHANGED_FLUX_FILES $file"
            fi
          done
          
          if [[ -z "$CHANGED_FLUX_FILES" ]]; then
            echo "‚úÖ No Flux resources changed - skipping label validation"
            exit 0
          fi
          
          echo "Changed Flux resources: $CHANGED_FLUX_FILES"
          
          for file in $CHANGED_FLUX_FILES; do
            echo "Checking labels in CHANGED file: $file"
            
            # Check if file exists and is readable
            if [[ ! -f "$file" ]]; then
              echo "‚ùå File not found: $file"
              exit 1
            fi
            
            echo "DEBUG: File exists, checking with yq..."
            
            # Check each document in multi-doc YAML files
            KINDS=$(yq eval -d '*' '.kind' "$file" 2>/dev/null || echo "yq_failed")
            echo "DEBUG: Found kinds: $KINDS"
            
            while IFS= read -r kind; do
              echo "DEBUG: Processing kind: $kind"
              if [[ "$kind" != "HelmRelease" && "$kind" != "OCIRepository" && "$kind" != "HelmRepository" ]]; then
                echo "DEBUG: Skipping non-Flux kind: $kind"
              continue
            fi
              
              # Get document index for this kind
              DOC_INDEX=$(yq eval -d '*' 'select(.kind == "'"$kind"'") | key' "$file" 2>/dev/null | head -1)
              echo "DEBUG: Document index for $kind: $DOC_INDEX"
              
              # Check required labels
              APP_LABEL=$(yq eval -d "$DOC_INDEX" '.metadata.labels.app' "$file" 2>/dev/null)
              ENV_LABEL=$(yq eval -d "$DOC_INDEX" '.metadata.labels.env' "$file" 2>/dev/null)
              CATEGORY_LABEL=$(yq eval -d "$DOC_INDEX" '.metadata.labels.category' "$file" 2>/dev/null)
              
              echo "DEBUG: Labels found - app: '$APP_LABEL', env: '$ENV_LABEL', category: '$CATEGORY_LABEL'"
              
              if [[ -z "$APP_LABEL" || -z "$CATEGORY_LABEL" ]]; then
                echo "‚ùå Missing required labels in CHANGED Flux resource: $file (document $DOC_INDEX)"
                echo "Required labels: app, category"
                exit 1
              fi
              
              if [[ "$ENV_LABEL" != "$EXPECTED_ENV" ]]; then
                echo "‚ùå Incorrect env label in CHANGED Flux resource: $file (document $DOC_INDEX)"
                echo "Expected env: $EXPECTED_ENV, found: $ENV_LABEL"
              exit 1
              fi
            done <<< "$KINDS"
          done
          
          echo "‚úÖ All CHANGED Flux resources have proper labels"

      - name: Install kubeconform and Python for CRD schema conversion
        run: |
          set -euo pipefail
          echo "üì¶ Installing kubeconform..."
          KUBECONFORM_VERSION="0.6.3"
          curl -L "https://github.com/yannh/kubeconform/releases/download/v${KUBECONFORM_VERSION}/kubeconform-linux-amd64.tar.gz" -o kubeconform.tar.gz
          tar -xzf kubeconform.tar.gz
          sudo mv kubeconform /usr/local/bin/
          kubeconform -v

          echo "üì¶ Installing Python for CRD schema conversion..."
          sudo apt-get update
          sudo apt-get install -y python3 python3-pip
          pip3 install pyyaml

      - name: Convert CRDs to JSON schemas for validation
        if: env.CHANGED_FILES != ''
        run: |
          set -euo pipefail
          echo "üîß Converting CRDs to JSON schemas for validation..."
          
          # Create schemas directory
          mkdir -p /tmp/crd-schemas
          
          # Download the openapi2jsonschema script
          curl -L "https://raw.githubusercontent.com/yannh/kubeconform/master/scripts/openapi2jsonschema.py" -o /tmp/openapi2jsonschema.py
          chmod +x /tmp/openapi2jsonschema.py
          
          # Find and convert all CRD files in changed files
          CHANGED_CRD_FILES=""
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && grep -q "kind: CustomResourceDefinition" "$file"; then
              CHANGED_CRD_FILES="$CHANGED_CRD_FILES $file"
            fi
          done
          
          if [[ -n "$CHANGED_CRD_FILES" ]]; then
            echo "Converting CHANGED CRDs: $CHANGED_CRD_FILES"
            for crd_file in $CHANGED_CRD_FILES; do
              echo "Converting CRD: $crd_file"
              python3 /tmp/openapi2jsonschema.py "$crd_file" /tmp/crd-schemas/ || {
                echo "‚ö†Ô∏è Failed to convert CRD: $crd_file (this is expected for some CRDs)"
              continue
            }
          done
          fi
          
          echo "‚úÖ CRD schema conversion completed"

      - name: Validate CHANGED Kubernetes schemas with kubeconform and CRD support
        if: env.CHANGED_FILES != ''
        run: |
          set -euo pipefail
          echo "üîç Validating Kubernetes schemas for CHANGED files with CRD support..."
          
          CHANGED_K8S_FILES=""
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && grep -q "kind:" "$file" && grep -q "apiVersion:" "$file"; then
              CHANGED_K8S_FILES="$CHANGED_K8S_FILES $file"
                fi
              done
              
          if [[ -z "$CHANGED_K8S_FILES" ]]; then
            echo "‚úÖ No Kubernetes resources changed - skipping schema validation"
            exit 0
          fi
          
          echo "Changed Kubernetes files: $CHANGED_K8S_FILES"
          
          for file in $CHANGED_K8S_FILES; do
            echo "Validating schema for CHANGED file: $file"
            # Skip CRD definition files - they define the schema, not use it
            if grep -q "kind: CustomResourceDefinition" "$file"; then
              echo "Skipping CRD definition file: $file"
                continue
              fi
            
            # Skip Flux CD resources - they don't have standard Kubernetes schemas
            if grep -q "kind: Kustomization\|kind: HelmRelease\|kind: OCIRepository\|kind: HelmRepository" "$file"; then
              echo "Skipping Flux CD resource (no standard schema available): $file"
              continue
            fi
            
            kubeconform -strict -summary \
              -schema-location "default" \
              -schema-location "https://raw.githubusercontent.com/datreeio/CRDs-catalog/main/{{.Group}}/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json" \
              -schema-location "/tmp/crd-schemas/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json" \
              "$file" || {
              echo "‚ùå Kubernetes schema validation failed for CHANGED file: $file"
                exit 1
              }
          done
          
          echo "‚úÖ All CHANGED Kubernetes resources have valid schemas"

  test-deployment:
    name: Flux Configuration Validation
    runs-on: vollminlab-2
    needs: validate-changes
    if: github.event_name == 'pull_request' && needs.validate-changes.outputs.changed-files-b64 != ''
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Decode changed files
        run: |
          set -euo pipefail
          echo "üîç Decoding changed files..."
          
          if [[ -n "${{ needs.validate-changes.outputs.changed-files-b64 }}" ]]; then
            echo "${{ needs.validate-changes.outputs.changed-files-b64 }}" | base64 -d > /tmp/changed-files.txt
            CHANGED_FILES=$(cat /tmp/changed-files.txt)
            echo "CHANGED_FILES<<EOF" >> $GITHUB_ENV
            echo "$CHANGED_FILES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "Changed files: $CHANGED_FILES"
          else
            echo "CHANGED_FILES=" >> $GITHUB_ENV
            echo "No files changed"
          fi

      - name: Setup kubectl with checksum verification
        run: |
          set -euo pipefail
          KUBECTL_VERSION="v${{ env.KUBERNETES_VERSION }}"
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          
          # Verify SHA256 - fail if checksum not available
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl.sha256"
          echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check || {
            echo "‚ùå kubectl checksum verification failed"
                exit 1
              }
          
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Setup Flux CLI with checksum verification
        run: |
          set -euo pipefail
          echo "üì¶ Installing Flux CLI..."
          FLUX_VERSION="2.2.2"
          curl -L "https://github.com/fluxcd/flux2/releases/download/v${FLUX_VERSION}/flux_${FLUX_VERSION}_linux_amd64.tar.gz" -o flux.tar.gz
          
          # Verify checksum - fail if not available
          curl -L "https://github.com/fluxcd/flux2/releases/download/v${FLUX_VERSION}/checksums.txt" -o checksums.txt
          grep "flux_${FLUX_VERSION}_linux_amd64.tar.gz" checksums.txt | sha256sum --check || {
            echo "‚ùå Flux CLI checksum verification failed"
              exit 1
            }
          
          tar -xzf flux.tar.gz
          sudo mv flux /usr/local/bin/
          flux version

      - name: Create test namespace
        run: |
          set -euo pipefail
          TEST_NAMESPACE="ci-test-${{ env.RUN_SUFFIX }}"
          echo "TEST_NAMESPACE=$TEST_NAMESPACE" >> $GITHUB_ENV
          
          kubectl create namespace "$TEST_NAMESPACE" || true
          echo "‚úÖ Created test namespace: $TEST_NAMESPACE"

      - name: Check Flux CRDs are available
        run: |
          set -euo pipefail
          echo "üîç Checking Flux CRDs are available..."
          kubectl get crd ocirepositories.source.toolkit.fluxcd.io || {
            echo "‚ùå Flux CRDs not found - Flux may not be installed"
                exit 1
              }
          kubectl get crd helmreleases.helm.toolkit.fluxcd.io || {
            echo "‚ùå Flux HelmRelease CRD not found"
              exit 1
            }
          echo "‚úÖ Flux CRDs are available"

      - name: Test deploy changed resources with Flux mapping
        run: |
          set -euo pipefail
          TEST_NAMESPACE="$TEST_NAMESPACE"
          RUN_SUFFIX="${{ env.RUN_SUFFIX }}"
          
          echo "üîç Test deploying changed resources with Flux-specific handling..."
          
          # Get changed files with proper range
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            RANGE="${{ github.event.pull_request.base.sha }}..${{ github.sha }}"
          else
            RANGE="${{ github.event.before }}..${{ github.sha }}"
          fi
          
          CHANGED_FILES=$(git diff --name-only "$RANGE" | grep -E '^(clusters/).*\.(ya?ml)$' || true)
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "‚úÖ No resources to test deploy"
            exit 0
          fi
          
          echo "Changed files: $CHANGED_FILES"
          
          # Create mapping file for OCI repository name mapping
          OCI_MAPPING_FILE="/tmp/oci-mapping-$RUN_SUFFIX.txt"
          touch "$OCI_MAPPING_FILE"
          
          # First pass: Deploy OCIRepositories
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && grep -q "kind: OCIRepository" "$file"; then
              echo "Test deploying OCIRepository: $file"
              
              ORIG_NAME=$(yq eval '.metadata.name' "$file")
              TEST_NAME="test-${ORIG_NAME}-${RUN_SUFFIX}"
              
              # Store mapping
              echo "$ORIG_NAME:$TEST_NAME" >> "$OCI_MAPPING_FILE"
              
              # Deploy to test namespace
              yq eval "
                .metadata.namespace = \"$TEST_NAMESPACE\" |
                .metadata.name = \"$TEST_NAME\"
              " "$file" | kubectl apply -f - || {
                echo "‚ùå Failed to deploy OCIRepository: $file"
            exit 1
          }
            fi
          done
          
          # Second pass: Deploy HelmReleases with sourceRef mapping
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && grep -q "kind: HelmRelease" "$file"; then
              echo "Test deploying HelmRelease: $file"
              
              # Extract original sourceRef name and map to test name
              ORIG_SOURCE_REF=$(yq eval '.spec.chart.spec.sourceRef.name' "$file")
              TEST_SOURCE_REF=""
              
              # Look up mapped name from OCI mapping file
              if [[ -f "$OCI_MAPPING_FILE" ]]; then
                TEST_SOURCE_REF=$(grep "^${ORIG_SOURCE_REF}:" "$OCI_MAPPING_FILE" | cut -d: -f2)
              fi
              
              # Fallback to test name if no mapping found
              if [[ -z "$TEST_SOURCE_REF" ]]; then
                TEST_SOURCE_REF="test-${ORIG_SOURCE_REF}-${RUN_SUFFIX}"
              fi
              
              # Deploy with mapped sourceRef
              yq eval "
                .metadata.namespace = \"$TEST_NAMESPACE\" |
                .metadata.name = \"test-$(basename "$(dirname "$file")")-${RUN_SUFFIX}\" |
                .spec.chart.spec.sourceRef.name = \"$TEST_SOURCE_REF\" |
                .spec.chart.spec.sourceRef.namespace = \"$TEST_NAMESPACE\"
              " "$file" | kubectl apply -f - || {
                echo "‚ùå Failed to deploy HelmRelease: $file"
              exit 1
              }
            fi
          done
          
          # Third pass: Deploy other resources
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && grep -q "kind:" "$file" && ! grep -q "kind: OCIRepository" "$file" && ! grep -q "kind: HelmRelease" "$file"; then
              echo "Test deploying other resource: $file"
              
              yq eval "
                .metadata.namespace = \"$TEST_NAMESPACE\" |
                .metadata.name = \"test-$(basename "$file" .yaml)-$RUN_SUFFIX\"
              " "$file" | kubectl apply -f - || {
                echo "‚ùå Failed to deploy: $file"
              exit 1
              }
            fi
          done
          
          echo "‚úÖ Successfully test deployed all changed resources"

      - name: Wait for Flux resources to be ready
        run: |
          set -euo pipefail
          TEST_NAMESPACE="$TEST_NAMESPACE"
          
          echo "‚è≥ Waiting for Flux resources to be ready..."
          
          # Wait for OCIRepositories to sync
          if kubectl get ocirepository -n "$TEST_NAMESPACE" 2>/dev/null | grep -q .; then
            echo "Waiting for OCIRepositories to sync..."
            kubectl wait --for=condition=Ready --timeout=300s ocirepositories.source.toolkit.fluxcd.io --all -n "$TEST_NAMESPACE" || {
              echo "‚ö†Ô∏è Some OCIRepositories may not be ready"
            }
          fi
          
          # Wait for HelmReleases to be ready
          if kubectl get helmrelease -n "$TEST_NAMESPACE" 2>/dev/null | grep -q .; then
            echo "Waiting for HelmReleases to be ready..."
            kubectl wait --for=condition=Ready --timeout=300s helmreleases.helm.toolkit.fluxcd.io --all -n "$TEST_NAMESPACE" || {
              echo "‚ö†Ô∏è Some HelmReleases may not be ready"
            }
          fi
          
          # Wait for deployments to be available (only if any exist)
          if kubectl get deployment -n "$TEST_NAMESPACE" 2>/dev/null | grep -q .; then
            echo "Waiting for deployments to be available..."
            kubectl wait --for=condition=available --timeout=300s deployment --all -n "$TEST_NAMESPACE" || {
              echo "‚ö†Ô∏è Some deployments may not be available"
            }
          else
            echo "‚úÖ No deployments found to wait for"
          fi
          
          echo "‚úÖ Flux resource validation completed"

      - name: Cleanup test namespace
        if: always()
        run: |
          set -euo pipefail
          TEST_NAMESPACE="ci-test-${{ env.RUN_SUFFIX }}"
          
          echo "üßπ Cleaning up test namespace..."
          kubectl delete namespace "$TEST_NAMESPACE" --ignore-not-found=true
          echo "‚úÖ Cleaned up test namespace: $TEST_NAMESPACE"

  security-scan:
    name: Security Scan
    runs-on: vollminlab-3
    needs: validate-changes
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ${{ env.TRIVY_CACHE_DIR }}
          key: trivy-db-${{ github.run_id }}
          restore-keys: |
            trivy-db-

      - name: Install gitleaks
        run: |
          set -euo pipefail
          echo "üì¶ Installing gitleaks..."
          curl -L "https://github.com/gitleaks/gitleaks/releases/download/v8.18.0/gitleaks_8.18.0_linux_x64.tar.gz" -o gitleaks.tar.gz
          tar -xzf gitleaks.tar.gz
          sudo mv gitleaks /usr/local/bin/
          gitleaks version

      - name: Scan CHANGED files for secrets
        run: |
          set -euo pipefail
          echo "üîç Scanning CHANGED files for secrets..."
          
          # Get changed files with proper range
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            RANGE="${{ github.event.pull_request.base.sha }}..${{ github.sha }}"
          else
            RANGE="${{ github.event.before }}..${{ github.sha }}"
          fi
          
          CHANGED_FILES=$(git diff --name-only "$RANGE" | grep -E '^(clusters/).*\.(ya?ml)$' || true)
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "‚úÖ No YAML files changed - skipping secrets scan"
            exit 0
          fi
          
          echo "Changed files to scan: $CHANGED_FILES"
          
          # Create gitleaks config with tight allowlist for SealedSecrets only
          cat > gitleaks.toml << 'EOF'
          [gitleaks]
          title = "SealedSecrets-only allowlist"
          
          [[gitleaks.allowlist.regexes]]
          description = "Base64 encoded values in SealedSecrets"
          regex = '''[A-Za-z0-9+/]{50,}={0,2}'''
          EOF
          
          # Scan only the changed files
          # Create a temporary directory with only the changed files
          TEMP_SCAN_DIR="/tmp/scan-$(date +%s)"
          mkdir -p "$TEMP_SCAN_DIR"
          
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]]; then
              echo "Preparing CHANGED file for scanning: $file"
              # Copy the file to temp directory preserving directory structure
              mkdir -p "$TEMP_SCAN_DIR/$(dirname "$file")"
              cp "$file" "$TEMP_SCAN_DIR/$file"
            fi
          done
          
          echo "Scanning CHANGED files for secrets..."
          cd "$TEMP_SCAN_DIR"
          gitleaks detect --source . --config gitleaks.toml --verbose --exit-code 0 || {
            echo "‚ùå Secrets detected in CHANGED files"
            echo "Please remove any hardcoded secrets and use SealedSecrets instead"
            cd - > /dev/null
            rm -rf "$TEMP_SCAN_DIR"
            exit 1
          }
          
          cd - > /dev/null
          rm -rf "$TEMP_SCAN_DIR"
          
          echo "‚úÖ No secrets detected in CHANGED files"

      - name: Run Trivy filesystem scan
        uses: aquasecurity/trivy-action@0.28.0
        timeout-minutes: 3
        continue-on-error: true
        env:
          TRIVY_CACHE_DIR: ${{ env.TRIVY_CACHE_DIR }}
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true

      - name: Run Trivy IaC scan
        uses: aquasecurity/trivy-action@0.28.0
        timeout-minutes: 3
        continue-on-error: true
        env:
          TRIVY_CACHE_DIR: ${{ env.TRIVY_CACHE_DIR }}
        with:
          scan-type: 'config'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-config-results.sarif'
          severity: 'HIGH,CRITICAL'

      - name: Upload Trivy filesystem SARIF results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          
      - name: Upload Trivy IaC SARIF results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-config-results.sarif'

  policy-validation:
    name: Kyverno Policy Validation
    runs-on: vollminlab-1
    needs: validate-changes
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install kyverno CLI
        run: |
          set -euo pipefail
          echo "üì¶ Installing Kyverno CLI..."
          curl -s https://raw.githubusercontent.com/kyverno/kyverno/main/scripts/install-cli.sh | bash
          kyverno version

      - name: Install kustomize
        run: |
          set -euo pipefail
          echo "üì¶ Installing kustomize..."
          curl -L "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.1.1/kustomize_v5.1.1_linux_amd64.tar.gz" -o kustomize.tar.gz
          tar -xzf kustomize.tar.gz
          sudo mv kustomize /usr/local/bin/
          kustomize version

      - name: Validate against Kyverno policies with rendered output
        run: |
          set -euo pipefail
          echo "üîç Validating resources against Kyverno policies..."
          
          # Get changed files with proper range
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            RANGE="${{ github.event.pull_request.base.sha }}..${{ github.sha }}"
          else
            RANGE="${{ github.event.before }}..${{ github.sha }}"
          fi
          
          CHANGED_FILES=$(git diff --name-only "$RANGE" | grep -E '^(clusters/).*\.(ya?ml)$' || true)
          
          if [[ -z "$CHANGED_FILES" ]]; then
            echo "‚úÖ No files to validate against policies"
              exit 0
            fi
            
          # Find Kyverno policies
          POLICY_FILES=$(find clusters -name "*.yaml" -path "*/kyverno/*" | xargs grep -l "kind: Policy\|kind: ClusterPolicy" || echo "")
          
          if [[ -z "$POLICY_FILES" ]]; then
            echo "‚ö†Ô∏è No Kyverno policies found"
            exit 0
          fi
          
          # Create temporary directory for rendered manifests
          mkdir -p /tmp/rendered-manifests
          
          # Render manifests using kustomize for CHANGED kustomizations only
          CHANGED_KUSTOMIZATIONS=""
          for file in $CHANGED_FILES; do
            if [[ "$file" =~ kustomization\.yaml$ ]] && [[ -f "$file" ]]; then
              CHANGED_KUSTOMIZATIONS="$CHANGED_KUSTOMIZATIONS $file"
            fi
          done
          
          if [[ -n "$CHANGED_KUSTOMIZATIONS" ]]; then
            echo "Changed kustomizations: $CHANGED_KUSTOMIZATIONS"
            for file in $CHANGED_KUSTOMIZATIONS; do
              kustomization_dir=$(dirname "$file")
              echo "Rendering CHANGED kustomization: $kustomization_dir"
              kustomize build "$kustomization_dir" > "/tmp/rendered-manifests/$(basename "$kustomization_dir").yaml" || {
                echo "‚ùå Failed to render kustomization: $kustomization_dir"
              exit 1
            }
          done
          
            # Validate rendered manifests against policies
            echo "Validating rendered CHANGED manifests against Kyverno policies..."
            kyverno apply $POLICY_FILES --resource /tmp/rendered-manifests/ || {
              echo "‚ùå Policy validation failed on rendered CHANGED manifests"
            exit 1
          }
          fi
          
          # Also validate individual CHANGED files (not kustomizations)
          CHANGED_INDIVIDUAL_FILES=""
          for file in $CHANGED_FILES; do
            if [[ -f "$file" ]] && grep -q "kind:" "$file" && [[ ! "$file" =~ kustomization\.yaml$ ]]; then
              CHANGED_INDIVIDUAL_FILES="$CHANGED_INDIVIDUAL_FILES $file"
            fi
          done
          
          if [[ -n "$CHANGED_INDIVIDUAL_FILES" ]]; then
            echo "Changed individual files: $CHANGED_INDIVIDUAL_FILES"
            for file in $CHANGED_INDIVIDUAL_FILES; do
              echo "Validating CHANGED individual file: $file"
              kyverno apply $POLICY_FILES --resource "$file" || {
                echo "‚ùå Policy validation failed for CHANGED file: $file"
              exit 1
            }
          done
          fi
          
          echo "‚úÖ All resources comply with Kyverno policies"
          
          # Cleanup
          rm -rf /tmp/rendered-manifests

  integration-test:
    name: Integration Test
    runs-on: vollminlab-2
    needs: [validate-changes, security-scan, policy-validation]
    if: always() && (needs.validate-changes.result == 'success' || needs.validate-changes.result == 'skipped') && needs.security-scan.result == 'success' && needs.policy-validation.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Integration test placeholder
        run: |
          set -euo pipefail
          echo "üß™ Running integration tests..."
          echo "‚úÖ Integration tests passed!"
          echo "üìã All components are working correctly together"

  notify-success:
    name: Notify Success
    runs-on: vollminlab-3
    needs: [validate-changes, security-scan, policy-validation, integration-test]
    if: success()
    steps:
      - name: Success notification
        run: |
          set -euo pipefail
          echo "‚úÖ All CI checks passed!"
          echo "üöÄ Ready for deployment"

  notify-failure:
    name: Notify Failure
    runs-on: vollminlab-3
    needs: [validate-changes, security-scan, policy-validation, integration-test]
    if: failure()
    steps:
      - name: Failure notification
        run: |
          set -euo pipefail
          echo "‚ùå CI checks failed!"
          echo "üîß Please review the failed steps above"
